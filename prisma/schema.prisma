generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Category {
  id            Int      @id @default(autoincrement())
  name          String   @db.VarChar(100)
  description   String?
  icon          String?  @db.VarChar(50)
  isActive      Boolean  @default(true) @map("is_active")
  executorCount Int      @default(0) @map("executor_count")
  orderCount    Int      @default(0) @map("order_count")
  createdAt     DateTime @default(now()) @map("created_at")
  orders        Order[]

  @@map("categories")
}

model User {
  id                 Int                @id @default(autoincrement())
  name               String             @db.VarChar(200)
  email              String             @unique @db.VarChar(255)
  phone              String?            @db.VarChar(20)
  passwordHash       String             @map("password_hash") @db.VarChar(255)
  role               UserRole
  status             UserStatus         @default(pending)
  registrationDate   DateTime           @default(now()) @map("registration_date")
  lastLogin          DateTime?          @map("last_login")
  location           String?            @db.VarChar(200)
  isVerified         Boolean            @default(false) @map("is_verified")
  legalStatus        String?            @map("legal_status") @db.VarChar(50)
  createdAt          DateTime           @default(now()) @map("created_at")
  complaintsAgainst  Complaint[]        @relation("ComplaintsAgainst")
  complaintsFiled    Complaint[]        @relation("ComplaintsFiled")
  resolvedComplaints Complaint[]        @relation("ResolvedComplaints")
  executorDocuments  ExecutorDocument[]
  verifiedDocuments  ExecutorDocument[] @relation("DocumentVerifier")
  executorProfile    ExecutorProfile?
  notifications      Notification[]
  clientOrders       Order[]            @relation("ClientOrders")
  executorOrders     Order[]            @relation("ExecutorOrders")
  clientReviews      Review[]           @relation("ReviewClient")
  executorReviews    Review[]           @relation("ReviewExecutor")
  subscriptions      Subscription[]

  @@map("users")
}

model ExecutorProfile {
  id              Int      @id @default(autoincrement())
  userId          Int      @unique @map("user_id")
  description     String?
  experience      String?  @db.VarChar(100)
  hourlyRate      Decimal? @map("hourly_rate") @db.Decimal(10, 2)
  categories      Int[]    @default([])
  workingHours    Json?    @map("working_hours")
  responseTime    String?  @map("response_time") @db.VarChar(50)
  completedOrders Int      @default(0) @map("completed_orders")
  rating          Decimal  @default(0) @db.Decimal(3, 2)
  reviewsCount    Int      @default(0) @map("reviews_count")
  createdAt       DateTime @default(now()) @map("created_at")
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("executor_profiles")
}

model ExecutorDocument {
  id                 Int                @id @default(autoincrement())
  userId             Int                @map("user_id")
  documentType       String             @map("document_type") @db.VarChar(100)
  filePath           String?            @map("file_path") @db.VarChar(500)
  fileName           String?            @map("file_name") @db.VarChar(255)
  verificationStatus VerificationStatus @default(pending) @map("verification_status")
  verifiedBy         Int?               @map("verified_by")
  verifiedAt         DateTime?          @map("verified_at")
  notes              String?
  createdAt          DateTime           @default(now()) @map("created_at")
  user               User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  verifiedByUser     User?              @relation("DocumentVerifier", fields: [verifiedBy], references: [id])

  @@map("executor_documents")
}

model Subscription {
  id            Int                @id @default(autoincrement())
  userId        Int                @map("user_id")
  planType      PlanType           @map("plan_type")
  startDate     DateTime           @map("start_date")
  endDate       DateTime           @map("end_date")
  status        SubscriptionStatus @default(active) @map("status")
  amount        Decimal            @db.Decimal(10, 2)
  paymentMethod String?            @map("payment_method") @db.VarChar(50)
  createdAt     DateTime           @default(now()) @map("created_at")
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model Order {
  id                 Int         @id @default(autoincrement())
  clientId           Int         @map("client_id")
  executorId         Int         @map("executor_id")
  categoryId         Int         @map("category_id")
  serviceDescription String      @map("service_description")
  address            String
  phone              String      @db.VarChar(20)
  clientName         String      @map("client_name") @db.VarChar(200)
  notes              String?
  orderDate          DateTime    @map("order_date") @db.Date
  orderTime          DateTime    @map("order_time") @db.Time(6)
  totalPrice         Decimal     @map("total_price") @db.Decimal(10, 2)
  status             OrderStatus @default(pending) @map("status")
  createdAt          DateTime    @default(now()) @map("created_at")
  updatedAt          DateTime    @default(now()) @map("updated_at")
  complaints         Complaint[]
  category           Category    @relation(fields: [categoryId], references: [id])
  client             User        @relation("ClientOrders", fields: [clientId], references: [id], onDelete: Cascade)
  executor           User        @relation("ExecutorOrders", fields: [executorId], references: [id], onDelete: Cascade)
  reviews            Review[]

  @@map("orders")
}

model Review {
  id         Int      @id @default(autoincrement())
  orderId    Int      @map("order_id")
  clientId   Int      @map("client_id")
  executorId Int      @map("executor_id")
  rating     Int
  comment    String?
  createdAt  DateTime @default(now()) @map("created_at")
  client     User     @relation("ReviewClient", fields: [clientId], references: [id], onDelete: Cascade)
  executor   User     @relation("ReviewExecutor", fields: [executorId], references: [id], onDelete: Cascade)
  order      Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@map("reviews")
}

model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  title     String   @db.VarChar(200)
  message   String
  type      String   @db.VarChar(50)
  isRead    Boolean  @default(false) @map("is_read")
  createdAt DateTime @default(now()) @map("created_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model Complaint {
  id             Int             @id @default(autoincrement())
  complainantId  Int             @map("complainant_id")
  accusedId      Int             @map("accused_id")
  orderId        Int?            @map("order_id")
  reason         String          @db.VarChar(200)
  description    String?
  status         ComplaintStatus @default(open) @map("status")
  adminNotes     String?         @map("admin_notes")
  resolvedBy     Int?            @map("resolved_by")
  resolvedAt     DateTime?       @map("resolved_at")
  createdAt      DateTime        @default(now()) @map("created_at")
  accused        User            @relation("ComplaintsAgainst", fields: [accusedId], references: [id], onDelete: Cascade)
  complainant    User            @relation("ComplaintsFiled", fields: [complainantId], references: [id], onDelete: Cascade)
  order          Order?          @relation(fields: [orderId], references: [id])
  resolvedByUser User?           @relation("ResolvedComplaints", fields: [resolvedBy], references: [id])

  @@map("complaints")
}

enum ComplaintStatus {
  open
  investigating
  resolved
  closed
}

enum OrderStatus {
  pending
  confirmed
  in_progress
  completed
  cancelled
}

enum PlanType {
  daily
  weekly
  monthly
}

enum SubscriptionStatus {
  active
  expired
  cancelled
}

enum UserRole {
  client
  executor
  admin
}

enum UserStatus {
  pending
  active
  blocked
  verified
}

enum VerificationStatus {
  pending
  verified
  rejected
}
